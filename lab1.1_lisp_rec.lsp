;; 1.1) LISP: Рекурсия - функция, проверяющая, есть ли в дереве Т 
;; хотя бы один путь (от корня до листа включительно), 
;; во всех вершинах которого находятся только положительные элементы

;; Пример использования

;; Дерево 1:
;;           5
;;         /   \
;;        3     8
;;       / \   /  \
;;      2  -1 -6  -4

;; Дерево 2:
;;           5
;;         /   \
;;        3     8
;;       / \   /  \
;;     -2  -1 -6  -4

;; Определяем переменные дерева с помощью defvar
(defvar tree1 '(5 (3 (2 nil nil) (-1 nil nil)) (8 (-6 nil nil) (-4 nil nil))))
(defvar tree2 '(5 (3 (-2 nil nil) (-1 nil nil)) (8 (-6 nil nil) (-4 nil nil))))

;; Определяем функцию для проверки положительных путей
(defun has-positive-path (tree)
  "Проверяет, существует ли хотя бы один путь от корня до листа, где все элементы положительные."
  (cond
    ;; Если дерево пустое, пути нет
    ((null tree) nil)

    ;; Если это лист (нет поддеревьев), проверяем его значение
    ((and (null (cadr tree)) (null (caddr tree)))  ;; Лист: два пустых поддеревья
     (> (car tree) 0))  ;; Если значение положительное, возвращаем T, иначе NIL

    ;; Если это не лист, проверяем корень и поддеревья
    (t
     (let ((value (car tree))         ;; Значение текущего узла
           (left (cadr tree))          ;; Левое поддерево
           (right (caddr tree)))       ;; Правое поддерево
       (and (> value 0)               ;; Проверяем, что текущий узел положительный
            (or (has-positive-path left)   ;; Проверяем левое поддерево
                (has-positive-path right)))))  ;; Проверяем правое поддеревое
))

;; Пример использования

(print (has-positive-path tree1))  ;; Результат: T (есть путь 5 -> 3 -> 2)
(print (has-positive-path tree2))  ;; Результат: NIL (нет пути с положительными значениями)
